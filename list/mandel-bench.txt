Sections:
00: "org0001:fc0" (FC0-FE2)
01: "org0002:1000" (1000-11D9)


Source: ".\Fast\mandel-bench.s"
                        	     1: ; Written By George Foot, modified by David Clifford Oct 2025
                        	     2: ; 6502 assembly language Mandelbrot Set plotter
                        	     3: ;
                        	     4: ; Inspired by Gordon Henderson's BASIC Mandlebrot benchmark:
                        	     5: ;   https://projects.drogon.net/retro-basic-benchmarking-with-mandelbrot/
                        	     6: ;
                        	     7: ; I wanted to make one in pure 6502 assembly language to see how fast it would run
                        	     8: ; on my computer.  I used a different fixed-point format, with 24-bit multiplication
                        	     9: ; to handle overflow.
                        	    10: ;
                        	    11: ; I used roughly the same characters as Gordon, but added some extras and repetitions
                        	    12: ; to allow for more iterations.  I'm also rendering a different region, tailored to
                        	    13: ; suit my PC's console window font.
                        	    14: 
                        	    15: ; Takes 5 seconds @32MHz
                        	    16: 
                        	    17: 	.org $0FC0
                        	    18: 
                        	    19: chars:
00:0FC0 20574D4023425846	    20: 	.byte " WM@#BXFGODC$&%*=FCODC$&%*=+~-;:,."
00:0FC8 474F44432426252A
00:0FD0 3D46434F44432426
00:0FD8 252A3D2B7E2D3B3A
00:0FE0 2C2E
                        	    21: MAXITER = *-chars
                        	    22: 
                        	    23: zp_a = $20
                        	    24: zp_b = $22
                        	    25: zp_aa = $24
                        	    26: zp_bb = $26
                        	    27: zp_ab = $28
                        	    28: zp_x = $2a
                        	    29: zp_y = $2c
                        	    30: 
                        	    31: zp_aasub = $2e
                        	    32: zp_bbsub = $2f
                        	    33: zp_absub = $31
                        	    34: zp_a24 = $32
                        	    35: zp_b24 = $35
                        	    36: 
                        	    37: zp_iter = $38
                        	    38: zp_xcount = $39
                        	    39: zp_ycount = $3a
                        	    40: 
                        	    41: 
                        	    42: ; Dimensions.  The maximums aren't actually used.
                        	    43: 
                        	    44: XMIN = $FE00  ; -2
                        	    45: XMAX = $0100  ; 1
                        	    46: XSTEP = $0018 ; 0.09375
                        	    47: YMIN = $FF00  ; -1
                        	    48: YMAX = $0100  ; 1
                        	    49: YSTEP = $0018 ; 0.09375
                        	    50: 
                        	    51: ; Width and height of region to display
                        	    52: 
                        	    53: XCOUNT = 32
                        	    54: YCOUNT = 24
                        	    55: 
                        	    56: 	.org $1000
                        	    57: start:
01:1000 A900            	    58: 	lda #<YMIN
01:1002 852C            	    59:     sta zp_y
01:1004 A9FF            	    60: 	lda #>YMIN
01:1006 852D            	    61:     sta zp_y+1
01:1008 A918            	    62: 	lda #YCOUNT
01:100A 853A            	    63:     sta zp_ycount
                        	    64: 
                        	    65: yloop:
01:100C A900            	    66: 	lda #<XMIN
01:100E 852A            	    67:     sta zp_x
01:1010 A9FE            	    68: 	lda #>XMIN
01:1012 852B            	    69:     sta zp_x+1
01:1014 A920            	    70: 	lda #XCOUNT
01:1016 8539            	    71:     sta zp_xcount
                        	    72: 
01:1018 A90A            	    73: 	lda #10
01:101A 207511          	    74: 	jsr IO_ECHO
                        	    75: 
                        	    76: xloop:
01:101D A52A            	    77: 	lda zp_x
01:101F 8520            	    78:     sta zp_a
01:1021 A52B            	    79: 	lda zp_x+1
01:1023 8521            	    80:     sta zp_a+1
                        	    81: 
01:1025 A52C            	    82: 	lda zp_y
01:1027 8522            	    83:     sta zp_b
01:1029 A52D            	    84: 	lda zp_y+1
01:102B 8523            	    85:     sta zp_b+1
                        	    86: 
01:102D A222            	    87: 	ldx #MAXITER
01:102F 8638            	    88: 	stx zp_iter
                        	    89: 
                        	    90: iterloop:
                        	    91: 
                        	    92: 	; Calculate aa = a*a, bb = b*b, ab = a*b
                        	    93: 	;
                        	    94: 	; We'll compute a*b into ab and copy it back to b afterwards
                        	    95: 	;
                        	    96: 	; We need 24-bit copies of a and b, and a byte of less significant bits for each result
                        	    97: 	;
                        	    98: 	; If any of these ever go >5 then we could abort as the overall calculation will then be out of range anyway
                        	    99: 	;
                        	   100: 	; If one but not both are negative then b should be negative at the end; but in general the calculation is
                        	   101: 	; done on absolute values
01:1031 A000            	   102: 	ldy #0 ; negative flag is bit 0
                        	   103: 
01:1033 A521            	   104: 	lda zp_a+1
01:1035 1014            	   105:     bpl positive1
                        	   106: 
01:1037 C8              	   107: 	iny ; flip sign
01:1038 38              	   108: 	sec
01:1039 A900            	   109: 	lda #0
01:103B E520            	   110:     sbc zp_a
01:103D 8520            	   111:     sta zp_a
01:103F 8532            	   112:     sta zp_a24
01:1041 A900            	   113: 	lda #0
01:1043 E521            	   114:     sbc zp_a+1
01:1045 8521            	   115:     sta zp_a+1
01:1047 8533            	   116:     sta zp_a24+1
01:1049 8006            	   117: 	bra continue1
                        	   118: 
                        	   119: positive1:
01:104B 8533            	   120: 	sta zp_a24+1
01:104D A520            	   121: 	lda zp_a
01:104F 8532            	   122:     sta zp_a24
                        	   123: 
                        	   124: continue1:
01:1051 6434            	   125: 	stz zp_a24+2
                        	   126: 
01:1053 A523            	   127: 	lda zp_b+1
01:1055 1014            	   128:     bpl positive2
                        	   129: 
01:1057 C8              	   130: 	iny ; flip sign
01:1058 38              	   131: 	sec
01:1059 A900            	   132: 	lda #0
01:105B E522            	   133:     sbc zp_b
01:105D 8522            	   134:     sta zp_b
01:105F 8535            	   135:     sta zp_b24
01:1061 A900            	   136: 	lda #0
01:1063 E523            	   137:     sbc zp_b+1
01:1065 8523            	   138:     sta zp_b+1
01:1067 8536            	   139:     sta zp_b24+1
01:1069 8006            	   140: 	bra continue2
                        	   141: 
                        	   142: positive2:
01:106B 8536            	   143: 	sta zp_b24+1
01:106D A522            	   144: 	lda zp_b
01:106F 8535            	   145:     sta zp_b24
                        	   146: 
                        	   147: continue2:
01:1071 6437            	   148: 	stz zp_b24+2
                        	   149: 
01:1073 642E            	   150: 	stz zp_aasub
01:1075 6424            	   151:     stz zp_aa
01:1077 6425            	   152:     stz zp_aa+1
01:1079 642F            	   153: 	stz zp_bbsub
01:107B 6426            	   154:     stz zp_bb
01:107D 6427            	   155:     stz zp_bb+1
01:107F 6431            	   156: 	stz zp_absub
01:1081 6428            	   157:     stz zp_ab
01:1083 6429            	   158:     stz zp_ab+1
                        	   159: 
                        	   160: bitloop_a:
                        	   161: 	; First deal with zp_a - shift right, see if the bit was set
01:1085 4621            	   162: 	lsr zp_a+1
01:1087 6620            	   163:     ror zp_a
01:1089 9026            	   164:     bcc bitloop_b
                        	   165: 
                        	   166: 	; Add a24 to aa
01:108B 18              	   167: 	clc
01:108C A52E            	   168: 	lda zp_aasub
01:108E 6532            	   169:     adc zp_a24
01:1090 852E            	   170:     sta zp_aasub
01:1092 A524            	   171: 	lda zp_aa
01:1094 6533            	   172:     adc zp_a24+1
01:1096 8524            	   173:     sta zp_aa
01:1098 A525            	   174: 	lda zp_aa+1
01:109A 6534            	   175:     adc zp_a24+2
01:109C 8525            	   176:     sta zp_aa+1
                        	   177: 	;bcs overflow
                        	   178: 
                        	   179: 	; Add b24 to ab
01:109E 18              	   180: 	clc
01:109F A531            	   181: 	lda zp_absub
01:10A1 6535            	   182:     adc zp_b24
01:10A3 8531            	   183:     sta zp_absub
01:10A5 A528            	   184: 	lda zp_ab
01:10A7 6536            	   185:     adc zp_b24+1
01:10A9 8528            	   186:     sta zp_ab
01:10AB A529            	   187: 	lda zp_ab+1
01:10AD 6537            	   188:     adc zp_b24+2
01:10AF 8529            	   189:     sta zp_ab+1
                        	   190: 	;bcs overflow
                        	   191: 
                        	   192: bitloop_b:
                        	   193: 	; Now deal with zp_b - shift right, see if the bit was set
01:10B1 4623            	   194: 	lsr zp_b+1
01:10B3 6622            	   195:     ror zp_b
01:10B5 9013            	   196:     bcc b_bit_done
                        	   197: 
                        	   198: 	; Add b24 to bb
01:10B7 18              	   199: 	clc
01:10B8 A52F            	   200: 	lda zp_bbsub
01:10BA 6535            	   201:     adc zp_b24
01:10BC 852F            	   202:     sta zp_bbsub
01:10BE A526            	   203: 	lda zp_bb
01:10C0 6536            	   204:     adc zp_b24+1
01:10C2 8526            	   205:     sta zp_bb
01:10C4 A527            	   206: 	lda zp_bb+1
01:10C6 6537            	   207:     adc zp_b24+2
01:10C8 8527            	   208:     sta zp_bb+1
                        	   209: 	;bcs overflow
                        	   210: 
                        	   211: b_bit_done:
                        	   212: 	; Shift a24 and b24 left
01:10CA 0632            	   213: 	asl zp_a24
01:10CC 2633            	   214:     rol zp_a24+1
01:10CE 2634            	   215:     rol zp_a24+2
01:10D0 0635            	   216: 	asl zp_b24
01:10D2 2636            	   217:     rol zp_b24+1
01:10D4 2637            	   218:     rol zp_b24+2
                        	   219: 
                        	   220: 	; If zp_a still has set bits, loop all the way back
01:10D6 A520            	   221: 	lda zp_a
01:10D8 0521            	   222:     ora zp_a+1
01:10DA D0A9            	   223:     bne bitloop_a
                        	   224: 
                        	   225: 	; Otherwise if zp_b has set bits, loop just back to there
01:10DC A522            	   226: 	lda zp_b
01:10DE 0523            	   227:     ora zp_b+1
01:10E0 D0CF            	   228:     bne bitloop_b
                        	   229: 
                        	   230: 	; Else we're done with the main multiplications
                        	   231: 
                        	   232: 	; Double ab into b
01:10E2 A531            	   233: 	lda zp_absub
01:10E4 0A              	   234:     asl
01:10E5 A528            	   235: 	lda zp_ab
01:10E7 2A              	   236:     rol
01:10E8 8522            	   237:     sta zp_b
01:10EA A529            	   238: 	lda zp_ab+1
01:10EC 2A              	   239:     rol
01:10ED 8523            	   240:     sta zp_b+1
                        	   241: 	;bcs overflow
                        	   242:     ;bmi overflow
                        	   243: 
                        	   244: 	; Correct the sign of b if it was meant to be negative
01:10EF 98              	   245: 	tya
01:10F0 2901            	   246:     and #1
01:10F2 F00D            	   247:     beq done
01:10F4 38              	   248: 	sec
01:10F5 A900            	   249: 	lda #0
01:10F7 E522            	   250:     sbc zp_b
01:10F9 8522            	   251:     sta zp_b
01:10FB A900            	   252: 	lda #0
01:10FD E523            	   253:     sbc zp_b+1
01:10FF 8523            	   254:     sta zp_b+1
                        	   255: ;	bra done
                        	   256: ;
                        	   257: ;overflow:
                        	   258: ;	bra iterloopend
                        	   259: 
                        	   260: done:
                        	   261: 	; Now aa = a*a, bb = b*b, b = 2*a*b
                        	   262: 	;
                        	   263: 	; We could check aa and bb against 5 here but probably not necessary.
                        	   264: 	; No need to check b as aa+bb>b
                        	   265: 
                        	   266: 	; Check aa+bb against 5
01:1101 18              	   267: 	clc
01:1102 A524            	   268: 	lda zp_aa
01:1104 6526            	   269:     adc zp_bb
01:1106 A525            	   270: 	lda zp_aa+1
01:1108 6527            	   271:     adc zp_bb+1
01:110A C905            	   272: 	cmp #5
01:110C B02E            	   273:     bcs iterloopend
                        	   274: 
                        	   275: 	; a=e-f+c
01:110E 38              	   276: 	sec
01:110F A524            	   277: 	lda zp_aa
01:1111 E526            	   278:     sbc zp_bb
01:1113 8520            	   279:     sta zp_a
01:1115 A525            	   280: 	lda zp_aa+1
01:1117 E527            	   281:     sbc zp_bb+1
01:1119 8521            	   282:     sta zp_a+1
                        	   283: 
01:111B 18              	   284: 	clc
01:111C A520            	   285: 	lda zp_a
01:111E 652A            	   286:     adc zp_x
01:1120 8520            	   287:     sta zp_a
01:1122 A521            	   288: 	lda zp_a+1
01:1124 652B            	   289:     adc zp_x+1
01:1126 8521            	   290:     sta zp_a+1
                        	   291: 
                        	   292: 	; b=b+d
01:1128 18              	   293: 	clc
01:1129 A522            	   294: 	lda zp_b
01:112B 652C            	   295:     adc zp_y
01:112D 8522            	   296:     sta zp_b
01:112F A523            	   297: 	lda zp_b+1
01:1131 652D            	   298:     adc zp_y+1
01:1133 8523            	   299:     sta zp_b+1
                        	   300: 
                        	   301: 	; iterate
01:1135 C638            	   302: 	dec zp_iter
01:1137 F003            	   303:     beq iterloopend
01:1139 4C3110          	   304: 	jmp iterloop
                        	   305: 
                        	   306: iterloopend:
01:113C A638            	   307: 	ldx zp_iter
01:113E BDC00F          	   308:     lda chars,x
01:1141 207511          	   309:     jsr IO_ECHO
01:1144 207511          	   310:     jsr IO_ECHO
                        	   311: 
                        	   312: xloopnext:
01:1147 18              	   313: 	clc
01:1148 A52A            	   314: 	lda zp_x
01:114A 6918            	   315:     adc #<XSTEP
01:114C 852A            	   316:     sta zp_x
01:114E A52B            	   317: 	lda zp_x+1
01:1150 6900            	   318:     adc #>XSTEP
01:1152 852B            	   319:     sta zp_x+1
                        	   320: 
01:1154 C639            	   321: 	dec zp_xcount
01:1156 F003            	   322:     beq xloopend
01:1158 4C1D10          	   323: 	jmp xloop
                        	   324: xloopend:
                        	   325: 
                        	   326: yloopnext:
01:115B 18              	   327: 	clc
01:115C A52C            	   328: 	lda zp_y
01:115E 6918            	   329:     adc #<YSTEP
01:1160 852C            	   330:     sta zp_y
01:1162 A52D            	   331: 	lda zp_y+1
01:1164 6900            	   332:     adc #>YSTEP
01:1166 852D            	   333:     sta zp_y+1
                        	   334: 
01:1168 C63A            	   335: 	dec zp_ycount
01:116A F003            	   336:     beq stop
01:116C 4C0C10          	   337: 	jmp yloop
                        	   338: 
                        	   339: stop:
01:116F A90A            	   340: 	lda #10
01:1171 207511          	   341: 	jsr IO_ECHO
01:1174 60              	   342: 	rts
                        	   343: 
                        	   344: 	.include io.s

Source: "io.s"
                        	     1: ACIA := $FF70
                        	     2: ACIAControl := ACIA+0
                        	     3: ACIAStatus := ACIA+0
                        	     4: ACIAData := ACIA+1
                        	     5: 
                        	     6: printptr = $80
                        	     7: 
                        	     8: ; Output character in A and return.
                        	     9: IO_ECHO:
01:1175 48              	    10: 	PHA
                        	    11: SerialOutWait:
01:1176 AD70FF          	    12: 	LDA	ACIAStatus
01:1179 2902            	    13: 	AND	#2
01:117B C902            	    14: 	CMP	#2
01:117D D0F7            	    15: 	BNE	SerialOutWait
01:117F 68              	    16: 	PLA
01:1180 8D71FF          	    17: 	STA	ACIAData
01:1183 60              	    18: 	RTS
                        	    19: 
                        	    20: IO_IMM:
01:1184 48              	    21: 	pha
01:1185 DA              	    22:     phx
01:1186 5A              	    23:     phy
                        	    24: 
01:1187 BA              	    25: 	tsx
01:1188 18              	    26: 	clc
01:1189 BD0401          	    27: 	lda $0104,x
01:118C 6901            	    28:     adc #1
01:118E 8580            	    29:     sta printptr
01:1190 BD0501          	    30: 	lda $0105,x
01:1193 6900            	    31:     adc #0
01:1195 8581            	    32:     sta printptr+1
                        	    33: 
01:1197 20A811          	    34: 	jsr printmsgloop
                        	    35: 
01:119A A580            	    36: 	lda printptr
01:119C 9D0401          	    37:     sta $0104,x
01:119F A581            	    38: 	lda printptr+1
01:11A1 9D0501          	    39:     sta $0105,x
                        	    40: 
01:11A4 7A              	    41: 	ply
01:11A5 FA              	    42:     plx
01:11A6 68              	    43:     pla
01:11A7 60              	    44: 	rts
                        	    45: 
                        	    46: printmsgloop:
01:11A8 A000            	    47: 	ldy #0
01:11AA B180            	    48: 	lda (printptr),y
01:11AC F00B            	    49: 	beq endprintmsgloop
01:11AE 207511          	    50: 	jsr IO_ECHO
01:11B1 E680            	    51: 	inc printptr
01:11B3 D0F3            	    52: 	bne printmsgloop
01:11B5 E681            	    53: 	inc printptr+1
01:11B7 80EF            	    54: 	bra printmsgloop
                        	    55: 
                        	    56: endprintmsgloop:
01:11B9 60              	    57: 	rts
                        	    58: 
                        	    59: 
                        	    60: ; Wait for key and return code in A
                        	    61: IO_KEY:
01:11BA AD70FF          	    62:     LDA	    ACIAStatus
01:11BD 2901            	    63:     AND	    #1
01:11BF C901            	    64:     CMP	    #1
01:11C1 D0F7            	    65:     BNE     IO_KEY
01:11C3 AD71FF          	    66:     LDA	    ACIAData
01:11C6 60              	    67:     RTS
                        	    68: 
                        	    69: ; Get next key press in A and set Carry.
                        	    70: ; If no key then clear carry and return zero in A.
                        	    71: IO_INKEY:
01:11C7 AD70FF          	    72:     LDA	    ACIAStatus
01:11CA 2901            	    73:     AND	    #1
01:11CC C901            	    74:     CMP	    #1
01:11CE D005            	    75:     BNE     NoKey
01:11D0 AD71FF          	    76:     LDA	    ACIAData
01:11D3 38              	    77:     SEC
01:11D4 60              	    78:     RTS
                        	    79: NoKey:
01:11D5 A900            	    80:     LDA     #0
01:11D7 18              	    81:     CLC
01:11D8 60              	    82:     RTS
                        	    83: 

Source: ".\Fast\mandel-bench.s"
                        	   345: 
                        	   346: 


Symbols by name:
ACIA                             E:FF70
ACIAData                         E:FF71
ACIAStatus                       E:FF70
IO_ECHO                          A:1175
IO_IMM                           A:1184
IO_INKEY                         A:11C7
IO_KEY                           A:11BA
MAXITER                          E:0022
NoKey                            A:11D5
SerialOutWait                    A:1176
XCOUNT                           E:0020
XMIN                             E:FE00
XSTEP                            E:0018
YCOUNT                           E:0018
YMIN                             E:FF00
YSTEP                            E:0018
b_bit_done                       A:10CA
bitloop_a                        A:1085
bitloop_b                        A:10B1
chars                            A:0FC0
continue1                        A:1051
continue2                        A:1071
done                             A:1101
endprintmsgloop                  A:11B9
iterloop                         A:1031
iterloopend                      A:113C
positive1                        A:104B
positive2                        A:106B
printmsgloop                     A:11A8
printptr                         E:0080
start                            A:1000
stop                             A:116F
xloop                            A:101D
xloopend                         A:115B
xloopnext                        A:1147
yloop                            A:100C
yloopnext                        A:115B
zp_a                             E:0020
zp_a24                           E:0032
zp_aa                            E:0024
zp_aasub                         E:002E
zp_ab                            E:0028
zp_absub                         E:0031
zp_b                             E:0022
zp_b24                           E:0035
zp_bb                            E:0026
zp_bbsub                         E:002F
zp_iter                          E:0038
zp_x                             E:002A
zp_xcount                        E:0039
zp_y                             E:002C
zp_ycount                        E:003A

Symbols by value:
0018 YSTEP
0018 XSTEP
0018 YCOUNT
0020 XCOUNT
0020 zp_a
0022 zp_b
0022 MAXITER
0024 zp_aa
0026 zp_bb
0028 zp_ab
002A zp_x
002C zp_y
002E zp_aasub
002F zp_bbsub
0031 zp_absub
0032 zp_a24
0035 zp_b24
0038 zp_iter
0039 zp_xcount
003A zp_ycount
0080 printptr
0FC0 chars
1000 start
100C yloop
101D xloop
1031 iterloop
104B positive1
1051 continue1
106B positive2
1071 continue2
1085 bitloop_a
10B1 bitloop_b
10CA b_bit_done
1101 done
113C iterloopend
1147 xloopnext
115B yloopnext
115B xloopend
116F stop
1175 IO_ECHO
1176 SerialOutWait
1184 IO_IMM
11A8 printmsgloop
11B9 endprintmsgloop
11BA IO_KEY
11C7 IO_INKEY
11D5 NoKey
FE00 XMIN
FF00 YMIN
FF70 ACIA
FF70 ACIAStatus
FF71 ACIAData
